CREATE DATABASE CURSOS

CREATE TABLE IF NOT EXIST aluno(
	id SERIAL PRIMARY KEY,
	nome VARCHAR(255),
	data_nascimento DATE,
	cpf NUMERIC NOT NULL UNIQUE
	
);

CREATE TABLE IF NOT EXIST categoria(
	id SERIAL PRIMARY KEY,
	categoria VARCHAR(255)
);

CREATE TABLE IF NOT EXIST curso(
	id SERIAL PRIMARY KEY,
	nome VARCHAR (255) UNIQUE,
	categoria_id INTEGER,
	FOREIGN KEY (categoria_id)
	REFERENCES categoria(id)
);

/* CRIANDO UMA TABELA COM REFERENCIA A VALORES DE OUTRA TABELA (CHAVE ESTRANGEIRA) */

CREATE TABLE IF NOT EXIST aluno_curso (
	aluno_id INTEGER NOT NULL,
	curso_id INTEGER NOT NULL,
	PRIMARY KEY (aluno_id, curso_id),
	FOREIGN KEY (aluno_id) 
	REFERENCES aluno(id),
	FOREIGN KEY (curso_id) 
	REFERENCES curso(id)
);

INSERT INTO aluno (nome,cpf,nascimento) VALUES(
	'Josué Assis', 
	'1999-07-12',
	12950091610
);


INSERT INTO aluno (nome,data_nascimento,cpf) VALUES(
	'Josué Ferreira',
	'1998-03-10',
	07659034073
),(
	'Edgar Marcedo',
	'2001-03-01',
	23866728085
),(
	'Tiago Nogueira',
	'2002-09-20',
	31151207020
);


INSERT INTO categoria VALUES 
	(1,'FRONT-END'),(2,'PROGRAMAÇÃO'),
	(3,'BANCO DE DADOS'),(4,'ADMINISTRAÇÃO');

INSERT INTO curso VALUES 
	(1,'Python',2),(2,'JAVA',2),(3,'HTML',1),
	(4,'CSS',1),(5,'MYSQL',3),(6,'POSTGRES',3),
	(7,'RUBY',2),(8,'Gestão de Projetos',4),
	(9,'JavaScript',1);



INSERT INTO aluno_curso VALUES
(1,1),(1,6),(1,8);

INSERT INTO aluno_curso VALUES
(1,1),(1,6),(1,8),(2,2),(2,5),(3,3),(3,4),(3,8),(4,5),(4,7);

/* MOSTRARA O NOME DO ALUNO COM SUA IDADE ATUAL */

SELECT aluno.nome AS NOME, EXTRACT(YEAR FROM AGE (data_nascimento)) AS idade FROM aluno;

/* FUNÇÃO DE CONVERSÃO DE TIMESTAMP PARA DATE */

SELECT NOW () :: DATE ;

SELECT TO_CHAR (NOW(),'DD/MM/YYYY);

/* FUNÇÃO COM CONCATENAÇÃO E EXTRASÃO DE INFORMAÇÕES USANDO NOVAMENTE O 'EXTRACT' */

SELECT (nome||' com idade de '||EXTRACT(YEAR FROM AGE (data_nascimento)) ||' anos') AS "APRESENTAÇÃO" FROM aluno;

                                   /* ESTRURA BASICA DE FUNÇÃO SQL */
		 /* FUNÇÃO PARA RETORNAR O DOBRO DOS VALORES DA COLUNA VALORES DA TABELA CURSO */

CREATE OR REPLACE FUNCTION teste_inteiro (curso) RETURNS NUMERIC AS $$
	SELECT $1.valor * 2 AS "Dobro"
$$ LANGUAGE sql;

SELECT nome, valor, teste_inteiro (curso) AS "dobro" FROM curso;

/* TAMBÉM É POSSÍVEL USAR O 'RETURN VOID' PARA CASO NÃO PRECISE RETORNAR VALOR' /*

	/* FUNÇÕES EM PLPGSQL /*
/* EXEMPLO DE CRIAÇÃO DE VARIAVEL INTERNA */

CREATE FUNCTION primeira_pl() RETURNS INTEGER AS $$
	DECLARE
		exemplo_var INTEGER DEFAULT(3);
	BEGIN
		RETURN exemplo_var;
	END;
$$ LANGUAGE PLPGSQL;

SELECT primeira_pl();

/* ESTRUTURA QUE RETORNARA VALORES OS QUAIS SEJAM MENORES DO QUE O VALOR PASSADO */

CREATE FUNCTION valor_baixo (valor_baixo NUMERIC(5,2)) RETURNS SETOF curso AS $$
	BEGIN
		RETURN QUERY SELECT * FROM curso
		WHERE valor < valor_baixo;
	END;
$$ LANGUAGE PLPGSQL;

/* USANDO UMA ESTRUTURA DE SELEÇÃO */

CREATE OR REPLACE FUNCTION demasiado_valor (curso curso,valor_escolhido NUMERIC) RETURNS VARCHAR AS $$
	BEGIN
		IF curso.valor > valor_escolhido THEN
			RETURN 'valor não acessivel';
		ELSEIF curso.valor <= valor_escolhido THEN
			RETURN 'valor acessivel';
		ELSE
			RETURN 'ERRO INESPERADO';
		END IF;
	END;
$$ LANGUAGE PLPGSQL;

SELECT nome,valor, demasiado_valor(curso,30.10) FROM curso ORDER BY demasiado_valor;

*/ OU USANDO CASE */

CREATE OR REPLACE FUNCTION demasiado_valor (curso curso,valor_escolhido NUMERIC) RETURNS VARCHAR AS $$
	BEGIN
		CASE  
			WHEN curso.valor > valor_escolhido THEN
				RETURN 'valor não acessivel';
			WHEN curso.valor <= valor_escolhido THEN
				RETURN 'valor acessivel';
		END CASE;
	END;
$$ LANGUAGE PLPGSQL;

SELECT nome,valor, demasiado_valor(curso,30.10) FROM curso ORDER BY demasiado_valor;
